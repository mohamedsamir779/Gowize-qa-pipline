{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getCacheKeyForURL } from './getCacheKeyForURL.js';\nimport '../_version.js';\n/**\n * Adds a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * NOTE: when called more than once this method will replace the previously set\n * configuration options. Calling it more than once is not recommended outside\n * of tests.\n *\n * @private\n * @param {Object} [options]\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URLs that should be checked for precache matches.\n */\nexport const addFetchListener = function () {\n  let {\n    ignoreURLParametersMatching = [/^utm_/],\n    directoryIndex = 'index.html',\n    cleanURLs = true,\n    urlManipulation\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const cacheName = cacheNames.getPrecacheName();\n  // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n  self.addEventListener('fetch', event => {\n    const precachedURL = getCacheKeyForURL(event.request.url, {\n      cleanURLs,\n      directoryIndex,\n      ignoreURLParametersMatching,\n      urlManipulation\n    });\n    if (!precachedURL) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\"Precaching did not find a match for \" + getFriendlyURL(event.request.url));\n      }\n      return;\n    }\n    let responsePromise = self.caches.open(cacheName).then(cache => {\n      return cache.match(precachedURL);\n    }).then(cachedResponse => {\n      if (cachedResponse) {\n        return cachedResponse;\n      }\n      // Fall back to the network if we don't have a cached response\n      // (perhaps due to manual cache cleanup).\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn(\"The precached response for \" + \"\".concat(getFriendlyURL(precachedURL), \" in \").concat(cacheName, \" was not found. \") + \"Falling back to the network instead.\");\n      }\n      return fetch(precachedURL);\n    });\n    if (process.env.NODE_ENV !== 'production') {\n      responsePromise = responsePromise.then(response => {\n        // Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(\"Precaching is responding to: \" + getFriendlyURL(event.request.url));\n        logger.log(\"Serving the precached url: \".concat(precachedURL));\n        logger.groupCollapsed(\"View request details here.\");\n        logger.log(event.request);\n        logger.groupEnd();\n        logger.groupCollapsed(\"View response details here.\");\n        logger.log(response);\n        logger.groupEnd();\n        logger.groupEnd();\n        return response;\n      });\n    }\n    event.respondWith(responsePromise);\n  });\n};","map":{"version":3,"names":["cacheNames","getFriendlyURL","logger","getCacheKeyForURL","addFetchListener","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","arguments","length","undefined","cacheName","getPrecacheName","self","addEventListener","event","precachedURL","request","url","process","env","NODE_ENV","debug","responsePromise","caches","open","then","cache","match","cachedResponse","warn","concat","fetch","response","groupCollapsed","log","groupEnd","respondWith"],"sources":["/home/ubuntu/king/portal/client-portal-starter/node_modules/workbox-precaching/utils/addFetchListener.js"],"sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getCacheKeyForURL } from './getCacheKeyForURL.js';\nimport '../_version.js';\n/**\n * Adds a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * NOTE: when called more than once this method will replace the previously set\n * configuration options. Calling it more than once is not recommended outside\n * of tests.\n *\n * @private\n * @param {Object} [options]\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URLs that should be checked for precache matches.\n */\nexport const addFetchListener = ({ ignoreURLParametersMatching = [/^utm_/], directoryIndex = 'index.html', cleanURLs = true, urlManipulation, } = {}) => {\n    const cacheName = cacheNames.getPrecacheName();\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('fetch', ((event) => {\n        const precachedURL = getCacheKeyForURL(event.request.url, {\n            cleanURLs,\n            directoryIndex,\n            ignoreURLParametersMatching,\n            urlManipulation,\n        });\n        if (!precachedURL) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Precaching did not find a match for ` +\n                    getFriendlyURL(event.request.url));\n            }\n            return;\n        }\n        let responsePromise = self.caches.open(cacheName).then((cache) => {\n            return cache.match(precachedURL);\n        }).then((cachedResponse) => {\n            if (cachedResponse) {\n                return cachedResponse;\n            }\n            // Fall back to the network if we don't have a cached response\n            // (perhaps due to manual cache cleanup).\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn(`The precached response for ` +\n                    `${getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` +\n                    `Falling back to the network instead.`);\n            }\n            return fetch(precachedURL);\n        });\n        if (process.env.NODE_ENV !== 'production') {\n            responsePromise = responsePromise.then((response) => {\n                // Workbox is going to handle the route.\n                // print the routing details to the console.\n                logger.groupCollapsed(`Precaching is responding to: ` +\n                    getFriendlyURL(event.request.url));\n                logger.log(`Serving the precached url: ${precachedURL}`);\n                logger.groupCollapsed(`View request details here.`);\n                logger.log(event.request);\n                logger.groupEnd();\n                logger.groupCollapsed(`View response details here.`);\n                logger.log(response);\n                logger.groupEnd();\n                logger.groupEnd();\n                return response;\n            });\n        }\n        event.respondWith(responsePromise);\n    }));\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}