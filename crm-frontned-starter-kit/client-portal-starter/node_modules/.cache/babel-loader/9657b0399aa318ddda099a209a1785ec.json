{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar R = _interopRequireWildcard(require(\"ramda\"));\nvar _bestFit = _interopRequireDefault(require(\"./bestFit\"));\nvar _linebreak = _interopRequireDefault(require(\"./linebreak\"));\nvar _slice = _interopRequireDefault(require(\"../../attributedString/slice\"));\nvar _insertGlyph = _interopRequireDefault(require(\"../../attributedString/insertGlyph\"));\nvar _advanceWidthBetween = _interopRequireDefault(require(\"../../attributedString/advanceWidthBetween\"));\nvar HYPHEN = 0x002d;\nvar TOLERANCE_STEPS = 5;\nvar TOLERANCE_LIMIT = 50;\nvar opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n/**\n * Slice attributed string to many lines\n *\n * @param {Object} attributed string\n * @param  {Array}  nodes\n * @param  {Array}  breaks\n * @return {Array} attributed strings\n */\n\nvar breakLines = function breakLines(string, nodes, breaks) {\n  var start = 0;\n  var end = null;\n  var lines = breaks.reduce(function (acc, breakPoint) {\n    var node = nodes[breakPoint.position];\n    var prevNode = nodes[breakPoint.position - 1]; // Last breakpoint corresponds to K&P mandatory final glue\n\n    if (breakPoint.position === nodes.length - 1) return acc;\n    var line;\n    if (node.type === 'penalty') {\n      end = prevNode.value.end;\n      line = (0, _slice[\"default\"])(start, end, string);\n      line = (0, _insertGlyph[\"default\"])(line.length, HYPHEN, line);\n    } else {\n      end = node.value.end;\n      line = (0, _slice[\"default\"])(start, end, string);\n    }\n    start = end;\n    return [].concat(acc, [line]);\n  }, []); // Last line\n\n  lines.push((0, _slice[\"default\"])(start, string.string.length, string));\n  return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param {Object} attributed string\n * @param  {Object}  attributed string\n * @param  {Object}  layout options\n * @return {Array} attributed strings\n */\n\nvar getNodes = function getNodes(attributedString, _ref, options) {\n  var align = _ref.align;\n  var start = 0;\n  var hyphenWidth = 5;\n  var syllables = attributedString.syllables;\n  var hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  var result = syllables.reduce(function (acc, s, index) {\n    var width = (0, _advanceWidthBetween[\"default\"])(start, start + s.length, attributedString);\n    if (s.trim() === '') {\n      var stretch = width * opts.width / opts.stretch;\n      var shrink = width * opts.width / opts.shrink;\n      var value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(_linebreak[\"default\"].glue(width, value, stretch, shrink));\n    } else {\n      var hyphenated = syllables[index + 1] !== ' ';\n      var _value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(_linebreak[\"default\"].box(width, _value, hyphenated));\n      if (syllables[index + 1] && hyphenated) {\n        acc.push(_linebreak[\"default\"].penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n    start += s.length;\n    return acc;\n  }, []);\n  result.push(_linebreak[\"default\"].glue(0, null, _linebreak[\"default\"].infinity, 0));\n  result.push(_linebreak[\"default\"].penalty(0, -_linebreak[\"default\"].infinity, 1));\n  return result;\n};\nvar getStyles = R.pathOr({}, ['attributedString', 'runs', 0, 'attributes']);\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @param {Object} attributed string\n * @return {Array} attributed strings\n */\n\nvar lineBreaker = function lineBreaker(options, attributedString, availableWidths) {\n  var tolerance = options.tolerance || 4;\n  var style = getStyles(attributedString);\n  var nodes = getNodes(attributedString, style, options);\n  var breaks = (0, _linebreak[\"default\"])(nodes, availableWidths, {\n    tolerance: tolerance\n  }); // Try again with a higher tolerance if the line breaking failed.\n\n  while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n    tolerance += TOLERANCE_STEPS;\n    breaks = (0, _linebreak[\"default\"])(nodes, availableWidths, {\n      tolerance: tolerance\n    });\n  }\n  if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\n    breaks = (0, _bestFit[\"default\"])(nodes, availableWidths);\n  }\n  return breakLines(attributedString, nodes, breaks.slice(1));\n};\nvar _default = R.curryN(3, lineBreaker);\nexports[\"default\"] = _default;","map":{"version":3,"names":["_interopRequireDefault","require","_interopRequireWildcard","exports","__esModule","R","_bestFit","_linebreak","_slice","_insertGlyph","_advanceWidthBetween","HYPHEN","TOLERANCE_STEPS","TOLERANCE_LIMIT","opts","width","stretch","shrink","breakLines","string","nodes","breaks","start","end","lines","reduce","acc","breakPoint","node","position","prevNode","length","line","type","value","concat","push","getNodes","attributedString","_ref","options","align","hyphenWidth","syllables","hyphenPenalty","hyphenationPenalty","result","s","index","trim","glue","hyphenated","_value","box","penalty","infinity","getStyles","pathOr","lineBreaker","availableWidths","tolerance","style","slice","_default","curryN"],"sources":["/home/ubuntu/king/portal/client-portal-starter/node_modules/@react-pdf/textkit/engines/linebreaker/index.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _bestFit = _interopRequireDefault(require(\"./bestFit\"));\n\nvar _linebreak = _interopRequireDefault(require(\"./linebreak\"));\n\nvar _slice = _interopRequireDefault(require(\"../../attributedString/slice\"));\n\nvar _insertGlyph = _interopRequireDefault(require(\"../../attributedString/insertGlyph\"));\n\nvar _advanceWidthBetween = _interopRequireDefault(require(\"../../attributedString/advanceWidthBetween\"));\n\nvar HYPHEN = 0x002d;\nvar TOLERANCE_STEPS = 5;\nvar TOLERANCE_LIMIT = 50;\nvar opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n/**\n * Slice attributed string to many lines\n *\n * @param {Object} attributed string\n * @param  {Array}  nodes\n * @param  {Array}  breaks\n * @return {Array} attributed strings\n */\n\nvar breakLines = function breakLines(string, nodes, breaks) {\n  var start = 0;\n  var end = null;\n  var lines = breaks.reduce(function (acc, breakPoint) {\n    var node = nodes[breakPoint.position];\n    var prevNode = nodes[breakPoint.position - 1]; // Last breakpoint corresponds to K&P mandatory final glue\n\n    if (breakPoint.position === nodes.length - 1) return acc;\n    var line;\n\n    if (node.type === 'penalty') {\n      end = prevNode.value.end;\n      line = (0, _slice[\"default\"])(start, end, string);\n      line = (0, _insertGlyph[\"default\"])(line.length, HYPHEN, line);\n    } else {\n      end = node.value.end;\n      line = (0, _slice[\"default\"])(start, end, string);\n    }\n\n    start = end;\n    return [].concat(acc, [line]);\n  }, []); // Last line\n\n  lines.push((0, _slice[\"default\"])(start, string.string.length, string));\n  return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param {Object} attributed string\n * @param  {Object}  attributed string\n * @param  {Object}  layout options\n * @return {Array} attributed strings\n */\n\n\nvar getNodes = function getNodes(attributedString, _ref, options) {\n  var align = _ref.align;\n  var start = 0;\n  var hyphenWidth = 5;\n  var syllables = attributedString.syllables;\n  var hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  var result = syllables.reduce(function (acc, s, index) {\n    var width = (0, _advanceWidthBetween[\"default\"])(start, start + s.length, attributedString);\n\n    if (s.trim() === '') {\n      var stretch = width * opts.width / opts.stretch;\n      var shrink = width * opts.width / opts.shrink;\n      var value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(_linebreak[\"default\"].glue(width, value, stretch, shrink));\n    } else {\n      var hyphenated = syllables[index + 1] !== ' ';\n      var _value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(_linebreak[\"default\"].box(width, _value, hyphenated));\n\n      if (syllables[index + 1] && hyphenated) {\n        acc.push(_linebreak[\"default\"].penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n\n    start += s.length;\n    return acc;\n  }, []);\n  result.push(_linebreak[\"default\"].glue(0, null, _linebreak[\"default\"].infinity, 0));\n  result.push(_linebreak[\"default\"].penalty(0, -_linebreak[\"default\"].infinity, 1));\n  return result;\n};\n\nvar getStyles = R.pathOr({}, ['attributedString', 'runs', 0, 'attributes']);\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @param {Object} attributed string\n * @return {Array} attributed strings\n */\n\nvar lineBreaker = function lineBreaker(options, attributedString, availableWidths) {\n  var tolerance = options.tolerance || 4;\n  var style = getStyles(attributedString);\n  var nodes = getNodes(attributedString, style, options);\n  var breaks = (0, _linebreak[\"default\"])(nodes, availableWidths, {\n    tolerance: tolerance\n  }); // Try again with a higher tolerance if the line breaking failed.\n\n  while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n    tolerance += TOLERANCE_STEPS;\n    breaks = (0, _linebreak[\"default\"])(nodes, availableWidths, {\n      tolerance: tolerance\n    });\n  }\n\n  if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\n    breaks = (0, _bestFit[\"default\"])(nodes, availableWidths);\n  }\n\n  return breakLines(attributedString, nodes, breaks.slice(1));\n};\n\nvar _default = R.curryN(3, lineBreaker);\n\nexports[\"default\"] = _default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}