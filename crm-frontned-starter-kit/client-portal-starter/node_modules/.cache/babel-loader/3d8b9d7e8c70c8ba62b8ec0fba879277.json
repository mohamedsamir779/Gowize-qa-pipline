{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority++) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  } // sum the factors at each priority\n\n  for (var j = 0; j < factors.length; j++) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  } // choose the priorities that need to be applied\n\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority++) {\n    var prioritySum = priorities[priority];\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      } // if this priority covers the remaining gap, we're done\n\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      } // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n\n      priorities[priority] = 1;\n      remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  } // zero out remaining priorities (if any)\n\n  for (var p = priority + 1; p <= NULL_PRIORITY; p++) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  } // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  } // create and return an array of distances to add to each glyph's advance\n\n  var distances = [];\n  for (var index = 0; index < factors.length; index++) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    } // if this glyph is unconstrained, add the unconstrained distance as well\n\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n    distances.push(dist);\n  }\n  return distances;\n};\nvar _default = getDistances;\nexports[\"default\"] = _default;","map":{"version":3,"names":["exports","__esModule","KASHIDA_PRIORITY","NULL_PRIORITY","getDistances","gap","factors","total","priorities","unconstrained","_priority","j","length","f","sum","before","after","priority","highestPriority","highestPrioritySum","remainingGap","prioritySum","Math","abs","p","distances","index","_f","next","dist","push","_default"],"sources":["/home/ubuntu/king/portal/client-portal-starter/node_modules/@react-pdf/textkit/engines/justification/getDistances.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\n\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority++) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  } // sum the factors at each priority\n\n\n  for (var j = 0; j < factors.length; j++) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  } // choose the priorities that need to be applied\n\n\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority++) {\n    var prioritySum = priorities[priority];\n\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      } // if this priority covers the remaining gap, we're done\n\n\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      } // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n\n\n      priorities[priority] = 1;\n      remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  } // zero out remaining priorities (if any)\n\n\n  for (var p = priority + 1; p <= NULL_PRIORITY; p++) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  } // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n\n\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  } // create and return an array of distances to add to each glyph's advance\n\n\n  var distances = [];\n\n  for (var index = 0; index < factors.length; index++) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    } // if this glyph is unconstrained, add the unconstrained distance as well\n\n\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n\n    distances.push(dist);\n  }\n\n  return distances;\n};\n\nvar _default = getDistances;\nexports[\"default\"] = _default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}