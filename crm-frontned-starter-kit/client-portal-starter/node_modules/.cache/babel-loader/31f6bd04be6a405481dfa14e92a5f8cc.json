{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async _ref => {\n  let {\n    request,\n    mode,\n    plugins = []\n  } = _ref;\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\n  let effectiveRequest = request;\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\n    effectiveRequest = await plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, {\n      mode,\n      request: effectiveRequest\n    });\n    if (typeof effectiveRequest === 'string') {\n      effectiveRequest = new Request(effectiveRequest);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(effectiveRequest, Request, {\n        moduleName: 'Plugin',\n        funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\n        isReturnValueProblem: true\n      });\n    }\n  }\n  return effectiveRequest;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async _ref2 => {\n  let {\n    request,\n    response,\n    event,\n    plugins = []\n  } = _ref2;\n  let responseToCache = response;\n  let pluginsUsed = false;\n  for (const plugin of plugins) {\n    if (\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin) {\n      pluginsUsed = true;\n      const pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\n      responseToCache = await pluginMethod.call(plugin, {\n        request,\n        response: responseToCache,\n        event\n      });\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\n            isReturnValueProblem: true\n          });\n        }\n      }\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (responseToCache) {\n        if (responseToCache.status !== 200) {\n          if (responseToCache.status === 0) {\n            logger.warn(\"The response for '\".concat(request.url, \"' is an opaque \") + \"response. The caching strategy that you're using will not \" + \"cache opaque responses by default.\");\n          } else {\n            logger.debug(\"The response for '\".concat(request.url, \"' returned \") + \"a status code of '\".concat(response.status, \"' and won't be cached as a \") + \"result.\");\n          }\n        }\n      }\n    }\n    responseToCache = responseToCache && responseToCache.status === 200 ? responseToCache : undefined;\n  }\n  return responseToCache ? responseToCache : null;\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async _ref3 => {\n  let {\n    cacheName,\n    request,\n    event,\n    matchOptions,\n    plugins = []\n  } = _ref3;\n  const cache = await self.caches.open(cacheName);\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins,\n    request,\n    mode: 'read'\n  });\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(\"Found a cached response in '\".concat(cacheName, \"'.\"));\n    } else {\n      logger.debug(\"No cached response found in '\".concat(cacheName, \"'.\"));\n    }\n  }\n  for (const plugin of plugins) {\n    if (\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin) {\n      const pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\n      cachedResponse = await pluginMethod.call(plugin, {\n        cacheName,\n        event,\n        matchOptions,\n        cachedResponse,\n        request: effectiveRequest\n      });\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n            isReturnValueProblem: true\n          });\n        }\n      }\n    }\n  }\n  return cachedResponse;\n};\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async _ref4 => {\n  let {\n    cacheName,\n    request,\n    response,\n    event,\n    plugins = [],\n    matchOptions\n  } = _ref4;\n  if (process.env.NODE_ENV !== 'production') {\n    if (request.method && request.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: request.method\n      });\n    }\n  }\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins,\n    request,\n    mode: 'write'\n  });\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(\"Cannot cache non-existent response for \" + \"'\".concat(getFriendlyURL(effectiveRequest.url), \"'.\"));\n    }\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(effectiveRequest.url)\n    });\n  }\n  const responseToCache = await _isResponseSafeToCache({\n    event,\n    plugins,\n    response,\n    request: effectiveRequest\n  });\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(\"Response '\".concat(getFriendlyURL(effectiveRequest.url), \"' will \") + \"not be cached.\", responseToCache);\n    }\n    return;\n  }\n  const cache = await self.caches.open(cacheName);\n  const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\n  const oldResponse = updatePlugins.length > 0 ? await matchWrapper({\n    cacheName,\n    matchOptions,\n    request: effectiveRequest\n  }) : null;\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(\"Updating the '\".concat(cacheName, \"' cache with a new Response for \") + \"\".concat(getFriendlyURL(effectiveRequest.url), \".\"));\n  }\n  try {\n    await cache.put(effectiveRequest, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n    throw error;\n  }\n  for (const plugin of updatePlugins) {\n    await plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\n      cacheName,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n      request: effectiveRequest\n    });\n  }\n};\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper\n};","map":{"version":3,"names":["assert","executeQuotaErrorCallbacks","getFriendlyURL","logger","pluginUtils","WorkboxError","_getEffectiveRequest","_ref","request","mode","plugins","cacheKeyWillBeUsedPlugins","filter","effectiveRequest","plugin","call","Request","process","env","NODE_ENV","isInstance","moduleName","funcName","isReturnValueProblem","_isResponseSafeToCache","_ref2","response","event","responseToCache","pluginsUsed","pluginMethod","Response","status","warn","concat","url","debug","undefined","matchWrapper","_ref3","cacheName","matchOptions","cache","self","caches","open","cachedResponse","match","putWrapper","_ref4","method","error","updatePlugins","oldResponse","length","put","name","newResponse","cacheWrapper"],"sources":["/home/ubuntu/Gowize-qa-pipline/client-portal-starter/node_modules/workbox-core/_private/cacheWrapper.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({ request, mode, plugins = [], }) => {\n    const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\n    let effectiveRequest = request;\n    for (const plugin of cacheKeyWillBeUsedPlugins) {\n        effectiveRequest = await plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, { mode, request: effectiveRequest });\n        if (typeof effectiveRequest === 'string') {\n            effectiveRequest = new Request(effectiveRequest);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(effectiveRequest, Request, {\n                moduleName: 'Plugin',\n                funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\n                isReturnValueProblem: true,\n            });\n        }\n    }\n    return effectiveRequest;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({ request, response, event, plugins = [], }) => {\n    let responseToCache = response;\n    let pluginsUsed = false;\n    for (const plugin of plugins) {\n        if (\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin) {\n            pluginsUsed = true;\n            const pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\n            responseToCache = await pluginMethod.call(plugin, {\n                request,\n                response: responseToCache,\n                event,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    assert.isInstance(responseToCache, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n            if (!responseToCache) {\n                break;\n            }\n        }\n    }\n    if (!pluginsUsed) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (responseToCache) {\n                if (responseToCache.status !== 200) {\n                    if (responseToCache.status === 0) {\n                        logger.warn(`The response for '${request.url}' is an opaque ` +\n                            `response. The caching strategy that you're using will not ` +\n                            `cache opaque responses by default.`);\n                    }\n                    else {\n                        logger.debug(`The response for '${request.url}' returned ` +\n                            `a status code of '${response.status}' and won't be cached as a ` +\n                            `result.`);\n                    }\n                }\n            }\n        }\n        responseToCache = responseToCache && responseToCache.status === 200 ?\n            responseToCache : undefined;\n    }\n    return responseToCache ? responseToCache : null;\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({ cacheName, request, event, matchOptions, plugins = [], }) => {\n    const cache = await self.caches.open(cacheName);\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'read'\n    });\n    let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n            logger.debug(`Found a cached response in '${cacheName}'.`);\n        }\n        else {\n            logger.debug(`No cached response found in '${cacheName}'.`);\n        }\n    }\n    for (const plugin of plugins) {\n        if (\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin) {\n            const pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\n            cachedResponse = await pluginMethod.call(plugin, {\n                cacheName,\n                event,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (cachedResponse) {\n                    assert.isInstance(cachedResponse, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n        }\n    }\n    return cachedResponse;\n};\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({ cacheName, request, response, event, plugins = [], matchOptions, }) => {\n    if (process.env.NODE_ENV !== 'production') {\n        if (request.method && request.method !== 'GET') {\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n                url: getFriendlyURL(request.url),\n                method: request.method,\n            });\n        }\n    }\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'write'\n    });\n    if (!response) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Cannot cache non-existent response for ` +\n                `'${getFriendlyURL(effectiveRequest.url)}'.`);\n        }\n        throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url),\n        });\n    }\n    const responseToCache = await _isResponseSafeToCache({\n        event,\n        plugins,\n        response,\n        request: effectiveRequest,\n    });\n    if (!responseToCache) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n                `not be cached.`, responseToCache);\n        }\n        return;\n    }\n    const cache = await self.caches.open(cacheName);\n    const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\n    const oldResponse = updatePlugins.length > 0 ?\n        await matchWrapper({ cacheName, matchOptions, request: effectiveRequest }) :\n        null;\n    if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n            `${getFriendlyURL(effectiveRequest.url)}.`);\n    }\n    try {\n        await cache.put(effectiveRequest, responseToCache);\n    }\n    catch (error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n            await executeQuotaErrorCallbacks();\n        }\n        throw error;\n    }\n    for (const plugin of updatePlugins) {\n        await plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\n            cacheName,\n            event,\n            oldResponse,\n            newResponse: responseToCache,\n            request: effectiveRequest,\n        });\n    }\n};\nexport const cacheWrapper = {\n    put: putWrapper,\n    match: matchWrapper,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}