{"ast":null,"code":"import zlib from 'zlib';\nvar range = function range(left, right, inclusive) {\n  var range = [];\n  var ascending = left < right;\n  var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n  for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n    range.push(i);\n  }\n  return range;\n};\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\nvar PNG = function () {\n  createClass(PNG, null, [{\n    key: 'decode',\n    value: function decode(path, fn) {\n      {\n        throw new Error('PNG.decode not available in browser build');\n      }\n    }\n  }, {\n    key: 'load',\n    value: function load(path) {\n      {\n        throw new Error('PNG.load not available in browser build');\n      }\n    }\n  }]);\n  function PNG(data) {\n    var _this = this;\n    classCallCheck(this, PNG);\n    var i = void 0;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n    while (true) {\n      var end;\n      var chunkSize = this.readUInt32();\n      var section = function () {\n        var result = [];\n        for (i = 0; i < 4; i++) {\n          result.push(String.fromCharCode(_this.data[_this.pos++]));\n        }\n        return result;\n      }().join('');\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n        case 'IDAT':\n          for (i = 0, end = chunkSize; i < end; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n          break;\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n              if (short > 0) {\n                var asc, end1;\n                for (i = 0, end1 = short, asc = 0 <= end1; asc ? i < end1 : i > end1; asc ? i++ : i--) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n          break;\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, toConsumableArray(Array.from(text.slice(0, index) || [])));\n          this.text[key] = String.fromCharCode.apply(String, toConsumableArray(Array.from(text.slice(index + 1) || [])));\n          break;\n        case 'IEND':\n          // we've got everything we need!\n          this.colors = function () {\n            switch (_this.colorType) {\n              case 0:\n              case 3:\n              case 4:\n                return 1;\n              case 2:\n              case 6:\n                return 3;\n            }\n          }();\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n          this.colorSpace = function () {\n            switch (_this.colors) {\n              case 1:\n                return 'DeviceGray';\n              case 3:\n                return 'DeviceRGB';\n            }\n          }();\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error(\"Incomplete or corrupt PNG file\");\n      }\n    }\n  }\n  createClass(PNG, [{\n    key: 'read',\n    value: function read(bytes) {\n      var _this2 = this;\n      return range(0, bytes, false).map(function (i) {\n        return _this2.data[_this2.pos++];\n      });\n    }\n  }, {\n    key: 'readUInt32',\n    value: function readUInt32() {\n      var b1 = this.data[this.pos++] << 24;\n      var b2 = this.data[this.pos++] << 16;\n      var b3 = this.data[this.pos++] << 8;\n      var b4 = this.data[this.pos++];\n      return b1 | b2 | b3 | b4;\n    }\n  }, {\n    key: 'readUInt16',\n    value: function readUInt16() {\n      var b1 = this.data[this.pos++] << 8;\n      var b2 = this.data[this.pos++];\n      return b1 | b2;\n    }\n  }, {\n    key: 'decodePixels',\n    value: function decodePixels(fn) {\n      var _this3 = this;\n      return zlib.inflate(this.imgData, function (err, data) {\n        if (err) {\n          throw err;\n        }\n        var pixelBytes = _this3.pixelBitlength / 8;\n        var scanlineLength = pixelBytes * _this3.width;\n        var pixels = new Buffer(scanlineLength * _this3.height);\n        var length = data.length;\n        var row = 0;\n        var pos = 0;\n        var c = 0;\n        while (pos < length) {\n          var byte, col, i, left, upper;\n          var end;\n          var end1;\n          var end2;\n          var end3;\n          var end4;\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0, end = scanlineLength; i < end; i++) {\n                pixels[c++] = data[pos++];\n              }\n              break;\n            case 1:\n              // Sub\n              for (i = 0, end1 = scanlineLength; i < end1; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                pixels[c++] = (byte + left) % 256;\n              }\n              break;\n            case 2:\n              // Up\n              for (i = 0, end2 = scanlineLength; i < end2; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (upper + byte) % 256;\n              }\n              break;\n            case 3:\n              // Average\n              for (i = 0, end3 = scanlineLength; i < end3; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n              break;\n            case 4:\n              // Paeth\n              for (i = 0, end4 = scanlineLength; i < end4; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n                var p = left + upper - upperLeft;\n                var pa = Math.abs(p - left);\n                var pb = Math.abs(p - upper);\n                var pc = Math.abs(p - upperLeft);\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n                pixels[c++] = (byte + paeth) % 256;\n              }\n              break;\n            default:\n              throw new Error('Invalid filter algorithm: ' + data[pos - 1]);\n          }\n          row++;\n        }\n        return fn(pixels);\n      });\n    }\n  }, {\n    key: 'decodePalette',\n    value: function decodePalette() {\n      var palette = this.palette;\n      var transparency = this.transparency.indexed || [];\n      var ret = new Buffer(transparency.length + palette.length);\n      var pos = 0;\n      var length = palette.length;\n      var c = 0;\n      for (var _i = 0, end = palette.length; _i < end; _i += 3) {\n        var left;\n        ret[pos++] = palette[_i];\n        ret[pos++] = palette[_i + 1];\n        ret[pos++] = palette[_i + 2];\n        ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n      }\n      return ret;\n    }\n  }, {\n    key: 'copyToImageData',\n    value: function copyToImageData(imageData, pixels) {\n      var j = void 0,\n        k = void 0;\n      var colors = this.colors;\n      var palette = null;\n      var alpha = this.hasAlphaChannel;\n      if (this.palette.length) {\n        palette = this._decodedPalette != null ? this._decodedPalette : this._decodedPalette = this.decodePalette();\n        colors = 4;\n        alpha = true;\n      }\n      var data = (imageData != null ? imageData.data : undefined) || imageData;\n      var length = data.length;\n      var input = palette || pixels;\n      var i = j = 0;\n      if (colors === 1) {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          var v = input[k++];\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      } else {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      }\n    }\n  }, {\n    key: 'decode',\n    value: function decode(fn) {\n      var _this4 = this;\n      var ret = new Buffer(this.width * this.height * 4);\n      return this.decodePixels(function (pixels) {\n        _this4.copyToImageData(ret, pixels);\n        return fn(ret);\n      });\n    }\n  }]);\n  return PNG;\n}();\nexport default PNG;","map":{"version":3,"names":["zlib","range","left","right","inclusive","ascending","end","i","push","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","toConsumableArray","arr","Array","isArray","arr2","from","PNG","value","decode","path","fn","Error","load","data","_this","pos","palette","imgData","transparency","text","chunkSize","readUInt32","section","result","String","fromCharCode","join","width","height","bits","colorType","compressionMethod","filterMethod","interlaceMethod","read","indexed","short","asc","end1","grayscale","rgb","index","indexOf","apply","slice","colors","hasAlphaChannel","includes","pixelBitlength","colorSpace","Buffer","bytes","_this2","map","b1","b2","b3","b4","readUInt16","decodePixels","_this3","inflate","err","pixelBytes","scanlineLength","pixels","row","c","byte","col","upper","end2","end3","end4","Math","floor","paeth","upperLeft","p","pa","abs","pb","pc","decodePalette","ret","_i","copyToImageData","imageData","j","k","alpha","_decodedPalette","undefined","input","v","_this4"],"sources":["/home/ubuntu/Gowize-qa-pipline/client-portal-starter/node_modules/@react-pdf/png-js/dist/png-js.browser.es.js"],"sourcesContent":["import zlib from 'zlib';\n\nvar range = function range(left, right, inclusive) {\n  var range = [];\n  var ascending = left < right;\n  var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n\n  for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n    range.push(i);\n  }\n\n  return range;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar PNG = function () {\n  createClass(PNG, null, [{\n    key: 'decode',\n    value: function decode(path, fn) {\n      {\n        throw new Error('PNG.decode not available in browser build');\n      }\n    }\n  }, {\n    key: 'load',\n    value: function load(path) {\n      {\n        throw new Error('PNG.load not available in browser build');\n      }\n    }\n  }]);\n\n  function PNG(data) {\n    var _this = this;\n\n    classCallCheck(this, PNG);\n\n    var i = void 0;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      var end;\n      var chunkSize = this.readUInt32();\n      var section = function () {\n        var result = [];\n        for (i = 0; i < 4; i++) {\n          result.push(String.fromCharCode(_this.data[_this.pos++]));\n        }\n        return result;\n      }().join('');\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0, end = chunkSize; i < end; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n              if (short > 0) {\n                var asc, end1;\n                for (i = 0, end1 = short, asc = 0 <= end1; asc ? i < end1 : i > end1; asc ? i++ : i--) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, toConsumableArray(Array.from(text.slice(0, index) || [])));\n          this.text[key] = String.fromCharCode.apply(String, toConsumableArray(Array.from(text.slice(index + 1) || [])));\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          this.colors = function () {\n            switch (_this.colorType) {\n              case 0:\n              case 3:\n              case 4:\n                return 1;\n              case 2:\n              case 6:\n                return 3;\n            }\n          }();\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          this.colorSpace = function () {\n            switch (_this.colors) {\n              case 1:\n                return 'DeviceGray';\n              case 3:\n                return 'DeviceRGB';\n            }\n          }();\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error(\"Incomplete or corrupt PNG file\");\n      }\n    }\n  }\n\n  createClass(PNG, [{\n    key: 'read',\n    value: function read(bytes) {\n      var _this2 = this;\n\n      return range(0, bytes, false).map(function (i) {\n        return _this2.data[_this2.pos++];\n      });\n    }\n  }, {\n    key: 'readUInt32',\n    value: function readUInt32() {\n      var b1 = this.data[this.pos++] << 24;\n      var b2 = this.data[this.pos++] << 16;\n      var b3 = this.data[this.pos++] << 8;\n      var b4 = this.data[this.pos++];\n      return b1 | b2 | b3 | b4;\n    }\n  }, {\n    key: 'readUInt16',\n    value: function readUInt16() {\n      var b1 = this.data[this.pos++] << 8;\n      var b2 = this.data[this.pos++];\n      return b1 | b2;\n    }\n  }, {\n    key: 'decodePixels',\n    value: function decodePixels(fn) {\n      var _this3 = this;\n\n      return zlib.inflate(this.imgData, function (err, data) {\n        if (err) {\n          throw err;\n        }\n\n        var pixelBytes = _this3.pixelBitlength / 8;\n        var scanlineLength = pixelBytes * _this3.width;\n\n        var pixels = new Buffer(scanlineLength * _this3.height);\n        var length = data.length;\n\n        var row = 0;\n        var pos = 0;\n        var c = 0;\n\n        while (pos < length) {\n          var byte, col, i, left, upper;\n          var end;\n          var end1;\n          var end2;\n          var end3;\n          var end4;\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0, end = scanlineLength; i < end; i++) {\n                pixels[c++] = data[pos++];\n              }\n              break;\n\n            case 1:\n              // Sub\n              for (i = 0, end1 = scanlineLength; i < end1; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                pixels[c++] = (byte + left) % 256;\n              }\n              break;\n\n            case 2:\n              // Up\n              for (i = 0, end2 = scanlineLength; i < end2; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (upper + byte) % 256;\n              }\n              break;\n\n            case 3:\n              // Average\n              for (i = 0, end3 = scanlineLength; i < end3; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n              break;\n\n            case 4:\n              // Paeth\n              for (i = 0, end4 = scanlineLength; i < end4; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n\n                var p = left + upper - upperLeft;\n                var pa = Math.abs(p - left);\n                var pb = Math.abs(p - upper);\n                var pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                pixels[c++] = (byte + paeth) % 256;\n              }\n              break;\n\n            default:\n              throw new Error('Invalid filter algorithm: ' + data[pos - 1]);\n          }\n\n          row++;\n        }\n\n        return fn(pixels);\n      });\n    }\n  }, {\n    key: 'decodePalette',\n    value: function decodePalette() {\n      var palette = this.palette;\n\n      var transparency = this.transparency.indexed || [];\n      var ret = new Buffer(transparency.length + palette.length);\n      var pos = 0;\n      var length = palette.length;\n\n      var c = 0;\n\n      for (var _i = 0, end = palette.length; _i < end; _i += 3) {\n        var left;\n        ret[pos++] = palette[_i];\n        ret[pos++] = palette[_i + 1];\n        ret[pos++] = palette[_i + 2];\n        ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n      }\n\n      return ret;\n    }\n  }, {\n    key: 'copyToImageData',\n    value: function copyToImageData(imageData, pixels) {\n      var j = void 0,\n          k = void 0;\n      var colors = this.colors;\n\n      var palette = null;\n      var alpha = this.hasAlphaChannel;\n\n      if (this.palette.length) {\n        palette = this._decodedPalette != null ? this._decodedPalette : this._decodedPalette = this.decodePalette();\n        colors = 4;\n        alpha = true;\n      }\n\n      var data = (imageData != null ? imageData.data : undefined) || imageData;\n      var length = data.length;\n\n      var input = palette || pixels;\n      var i = j = 0;\n\n      if (colors === 1) {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          var v = input[k++];\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      } else {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      }\n    }\n  }, {\n    key: 'decode',\n    value: function decode(fn) {\n      var _this4 = this;\n\n      var ret = new Buffer(this.width * this.height * 4);\n      return this.decodePixels(function (pixels) {\n        _this4.copyToImageData(ret, pixels);\n        return fn(ret);\n      });\n    }\n  }]);\n  return PNG;\n}();\n\nexport default PNG;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}