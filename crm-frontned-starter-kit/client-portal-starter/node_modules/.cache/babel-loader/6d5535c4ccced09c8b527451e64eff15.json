{"ast":null,"code":"// Generated by CoffeeScript 1.7.1\n(function () {\n  var Struct,\n    VersionedStruct,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function (child, parent) {\n      for (var key in parent) {\n        if (__hasProp.call(parent, key)) child[key] = parent[key];\n      }\n      function ctor() {\n        this.constructor = child;\n      }\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    };\n  Struct = require('./Struct');\n  VersionedStruct = function (_super) {\n    __extends(VersionedStruct, _super);\n    function VersionedStruct(type, versions) {\n      this.type = type;\n      this.versions = versions != null ? versions : {};\n      if (typeof this.type === 'string') {\n        this.versionGetter = new Function('parent', \"return parent.\" + this.type);\n        this.versionSetter = new Function('parent', 'version', \"return parent.\" + this.type + \" = version\");\n      }\n    }\n    VersionedStruct.prototype.decode = function (stream, parent, length) {\n      var fields, res, _ref;\n      if (length == null) {\n        length = 0;\n      }\n      res = this._setup(stream, parent, length);\n      if (typeof this.type === 'string') {\n        res.version = this.versionGetter(parent);\n      } else {\n        res.version = this.type.decode(stream);\n      }\n      if (this.versions.header) {\n        this._parseFields(stream, res, this.versions.header);\n      }\n      fields = this.versions[res.version];\n      if (fields == null) {\n        throw new Error(\"Unknown version \" + res.version);\n      }\n      if (fields instanceof VersionedStruct) {\n        return fields.decode(stream, parent);\n      }\n      this._parseFields(stream, res, fields);\n      if ((_ref = this.process) != null) {\n        _ref.call(res, stream);\n      }\n      return res;\n    };\n    VersionedStruct.prototype.size = function (val, parent, includePointers) {\n      var ctx, fields, key, size, type, _ref;\n      if (includePointers == null) {\n        includePointers = true;\n      }\n      if (!val) {\n        throw new Error('Not a fixed size');\n      }\n      ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      size = 0;\n      if (typeof this.type !== 'string') {\n        size += this.type.size(val.version, ctx);\n      }\n      if (this.versions.header) {\n        _ref = this.versions.header;\n        for (key in _ref) {\n          type = _ref[key];\n          if (type.size != null) {\n            size += type.size(val[key], ctx);\n          }\n        }\n      }\n      fields = this.versions[val.version];\n      if (fields == null) {\n        throw new Error(\"Unknown version \" + val.version);\n      }\n      for (key in fields) {\n        type = fields[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n      return size;\n    };\n    VersionedStruct.prototype.encode = function (stream, val, parent) {\n      var ctx, fields, i, key, ptr, type, _ref, _ref1;\n      if ((_ref = this.preEncode) != null) {\n        _ref.call(val, stream);\n      }\n      ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n      if (typeof this.type !== 'string') {\n        this.type.encode(stream, val.version);\n      }\n      if (this.versions.header) {\n        _ref1 = this.versions.header;\n        for (key in _ref1) {\n          type = _ref1[key];\n          if (type.encode != null) {\n            type.encode(stream, val[key], ctx);\n          }\n        }\n      }\n      fields = this.versions[val.version];\n      for (key in fields) {\n        type = fields[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n      i = 0;\n      while (i < ctx.pointers.length) {\n        ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    };\n    return VersionedStruct;\n  }(Struct);\n  module.exports = VersionedStruct;\n}).call(this);","map":{"version":3,"names":["Struct","VersionedStruct","__hasProp","hasOwnProperty","__extends","child","parent","key","call","ctor","constructor","prototype","__super__","require","_super","type","versions","versionGetter","Function","versionSetter","decode","stream","length","fields","res","_ref","_setup","version","header","_parseFields","Error","process","size","val","includePointers","ctx","pointerSize","encode","i","ptr","_ref1","preEncode","pointers","startOffset","pos","pointerOffset","module","exports"],"sources":["/home/ubuntu/Gowize-qa-pipline/client-portal-starter/node_modules/restructure/src/VersionedStruct.js"],"sourcesContent":["// Generated by CoffeeScript 1.7.1\n(function() {\n  var Struct, VersionedStruct,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  Struct = require('./Struct');\n\n  VersionedStruct = (function(_super) {\n    __extends(VersionedStruct, _super);\n\n    function VersionedStruct(type, versions) {\n      this.type = type;\n      this.versions = versions != null ? versions : {};\n      if (typeof this.type === 'string') {\n        this.versionGetter = new Function('parent', \"return parent.\" + this.type);\n        this.versionSetter = new Function('parent', 'version', \"return parent.\" + this.type + \" = version\");\n      }\n    }\n\n    VersionedStruct.prototype.decode = function(stream, parent, length) {\n      var fields, res, _ref;\n      if (length == null) {\n        length = 0;\n      }\n      res = this._setup(stream, parent, length);\n      if (typeof this.type === 'string') {\n        res.version = this.versionGetter(parent);\n      } else {\n        res.version = this.type.decode(stream);\n      }\n      if (this.versions.header) {\n        this._parseFields(stream, res, this.versions.header);\n      }\n      fields = this.versions[res.version];\n      if (fields == null) {\n        throw new Error(\"Unknown version \" + res.version);\n      }\n      if (fields instanceof VersionedStruct) {\n        return fields.decode(stream, parent);\n      }\n      this._parseFields(stream, res, fields);\n      if ((_ref = this.process) != null) {\n        _ref.call(res, stream);\n      }\n      return res;\n    };\n\n    VersionedStruct.prototype.size = function(val, parent, includePointers) {\n      var ctx, fields, key, size, type, _ref;\n      if (includePointers == null) {\n        includePointers = true;\n      }\n      if (!val) {\n        throw new Error('Not a fixed size');\n      }\n      ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      size = 0;\n      if (typeof this.type !== 'string') {\n        size += this.type.size(val.version, ctx);\n      }\n      if (this.versions.header) {\n        _ref = this.versions.header;\n        for (key in _ref) {\n          type = _ref[key];\n          if (type.size != null) {\n            size += type.size(val[key], ctx);\n          }\n        }\n      }\n      fields = this.versions[val.version];\n      if (fields == null) {\n        throw new Error(\"Unknown version \" + val.version);\n      }\n      for (key in fields) {\n        type = fields[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n      return size;\n    };\n\n    VersionedStruct.prototype.encode = function(stream, val, parent) {\n      var ctx, fields, i, key, ptr, type, _ref, _ref1;\n      if ((_ref = this.preEncode) != null) {\n        _ref.call(val, stream);\n      }\n      ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n      if (typeof this.type !== 'string') {\n        this.type.encode(stream, val.version);\n      }\n      if (this.versions.header) {\n        _ref1 = this.versions.header;\n        for (key in _ref1) {\n          type = _ref1[key];\n          if (type.encode != null) {\n            type.encode(stream, val[key], ctx);\n          }\n        }\n      }\n      fields = this.versions[val.version];\n      for (key in fields) {\n        type = fields[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n      i = 0;\n      while (i < ctx.pointers.length) {\n        ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    };\n\n    return VersionedStruct;\n\n  })(Struct);\n\n  module.exports = VersionedStruct;\n\n}).call(this);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}