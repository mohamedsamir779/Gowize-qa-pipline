const { ECPairFactory } = require('ecpair');
const ecc = require('tiny-secp256k1');
const bitcoin = require('bitcoinjs-lib');
const Websocket = require('ws');
const {
  CONSTANTS,
} = require('src/common/data');
const {
  logger,
} = require('src/common/lib');
const {
  sleep,
} = require('src/common/handlers');

const ECPair = ECPairFactory(ecc);

const LogTag = 'BTCChain';
const RequiredConfirmations = 1;

let addressTrackerService;
let transactionService;
let addressService;
let walletService;

const processTxOutput = async (chainId, tx, vout, addressList = [], requiredConfirmations) => {
  const address = vout.addresses[0];
  // check if the address is of any interest to us (generated by us)
  if (!(addressList.indexOf(address) >= 0)) {
    logger.info(`${LogTag}: address not found in list: ${address}`);
    return;
  }
  const {
    confirmations,
    hash,
    inputs,
    received,
    confirmed,
  } = tx;
  const from = inputs[0].addresses[0];
  const to = vout.addresses[0];
  let dataToAdd = {
    from,
    to,
    amount: vout.value / CONSTANTS.SATOSHI_VALUE,
    confirmations,
    txId: hash,
    recievedTime: received,
    confirmedTime: confirmed,
  };
  const foundTxInDb = await transactionService.findOne({ txId: hash });
  const addressDetails = await addressService.findOne({ address: to });
  const wallet = await walletService.findOne({
    networks: addressDetails._id,
    asset: 'BTC',
  });
  if (confirmations < requiredConfirmations) {
    logger.info(`${LogTag}: ${confirmations} Confimations is lesser than Requried: ${requiredConfirmations} Address: ${to}`);
    logger.info(`${LogTag}: ============ adding as a pending transaction=============== : Address : ${to}`);
    if (!foundTxInDb) {
      if (wallet) {
        dataToAdd = {
          ...dataToAdd,
          walletId: wallet._id,
          customerId: wallet.belongsTo,
          currency: wallet.asset,
        };
        logger.info(`${LogTag}: Creating a pending deposit transaction with details: ${JSON.stringify(dataToAdd)}`);
        await transactionService.createPendingTransaction(
          CONSTANTS.TRANSACTIONS_TYPES.DEPOSIT,
          dataToAdd,
        );
      } else {
        logger.warn(`${LogTag}: wallet was not found to deposit funds into Address: ${addressDetails.address} Amount: ${dataToAdd.amount}`);
      }
    } else {
      logger.info(`${LogTag}: Updating confirmations for transaction: ${foundTxInDb._id}: Confirmations: ${confirmations}`);
      await transactionService.updateById(
        foundTxInDb._id, {
          confirmations: dataToAdd.confirmations,
        },
      );
    }
  } else if (confirmations >= requiredConfirmations) {
    logger.info(`${LogTag}: Transaction Confirmed Reached Required Confirmations: ${requiredConfirmations}: Confirmations: ${confirmations}, Approving Transaction: ${foundTxInDb._id}`);
    await transactionService.approveDeposit({ id: foundTxInDb._id });
  }
};

const defaultAddressCallback = async (chainId, data, confimations = 6) => {
  logger.info(`${LogTag}: message Recieved ==> ${data}`);
  const addressList = await addressTrackerService.findOne({ chainId }, {}, { lean: true });
  if (!addressList || !addressList.address) {
    logger.error(`${LogTag}: Address List for chain not found in database`);
    return;
  }
  if (addressList && addressList.address && addressList.address.length === 0) {
    logger.error(`${LogTag}: Empty Address List`);
    return;
  }
  const parsedTx = JSON.parse(data);
  if (parsedTx.outputs) {
    for (let index = 0; index < parsedTx.outputs.length; index++) {
      processTxOutput(
        chainId,
        parsedTx,
        parsedTx.outputs[index],
        addressList.address,
        confimations,
      );
    }
  }
};

const heartbeat = (ws, delay) => {
  logger.info(`BTCChain: opnened connection heartbeat ==> ${delay}`);
  ws.pingTimeout = setInterval(() => {
    ws.send(JSON.stringify({ event: 'ping' }));
  }, delay);
};

class BTCChain {
  constructor(options = {}) {
    this.LogTag = options.LogTag || LogTag;
    this.heartbeatTimeout = 20000;
    this.confirmations = options.confirmations || RequiredConfirmations;
    this.testnet = options.testnet || false;
    this.token = options.token || '1bc2e0d63d98493686f8165ec763f930';
    this.websocketUrl = options.websocketUrl || `wss://socket.blockcypher.com/v1/btc/${this.testnet ? 'test3' : 'main'}?token=${this.token}`;
    if (!options.chainId) throw new Error(`${this.LogTag}: This requires a database id`);
    this.chainId = options.chainId;
    if (!options.defaultAddressCallback) logger.warn(`${this.LogTag}: You have not provided a default callback to the address listener`);
    this.defaultAddressCallback = options.defaultAddressCallback || defaultAddressCallback;
  }

  async GenerateKeyPairs(listen = true) {
    const keyPair = ECPair.makeRandom();
    const { address } = bitcoin.payments.p2pkh({ pubkey: keyPair.publicKey });
    const publicKey = keyPair.publicKey.toString('hex');
    const privateKey = keyPair.toWIF();
    if (listen) this.addAddressToListener(address);
    return { address, privateKey, publicKey };
  }

  async InitializeAddresses() {
    const addressData = await addressTrackerService.findOne({ chainId: this.chainId });
    if (!addressData) {
      logger.info(`${this.LogTag}: This chain does not have any saved address data`);
    }
    if (addressData && addressData.address && addressData.address.length !== 0) {
      for (let i = 0; i < addressData.address.length; i++) {
        await sleep(5000);
        const curAdr = addressData.address[i];
        this.addAddressToListener(curAdr);
      }
    } else if (addressData && addressData.address && addressData.address.length === 0) {
      logger.info(`${this.LogTag}: This chain does not have any saved addresses in the list`);
    }
  }

  createConnection() {
    this.client = new Websocket(this.websocketUrl, {
      rejectUnauthorized: false,
    });
    const { client, heartbeatTimeout } = this;
    this.client.on('open', () => {
      heartbeat(client, heartbeatTimeout);
      this.addressListener();
      this.InitializeAddresses();
    });
  }

  async addAddressToListener(addressToListen) {
    if (!addressToListen) throw new Error(`${this.LogTag}: No address provided`);
    if (this.client) {
      if (!this.addressListenerCallback) throw new Error(`${this.LogTag}: Address Listener is not defined`);
      this.client.send(JSON.stringify({
        event: CONSTANTS.BLOCKCYPHER_WEBSOCKET_EVENTS.TX_CONFIMATION,
        address: addressToListen,
      }));
      logger.info(`${this.LogTag}: Added ${addressToListen} to the blockchain transaction listener`);
    } else {
      throw new Error(`${this.LogTag}: WS client is not defined`);
    }
  }

  async addressListener(addressListenerCallback = this.defaultAddressCallback) {
    this.addressListenerCallback = addressListenerCallback;
    if (this.addressListenerCallback) {
      this.client.on('message', (data) => addressListenerCallback(this.chainId, data, this.confirmations));
    } else {
      throw new Error(`${this.LogTag}: Address Listener is not defined`);
    }
  }
}

module.exports = BTCChain;

setTimeout(() => {
  // eslint-disable-next-line global-require
  const services = require('src/modules/services');
  addressTrackerService = services.addressTrackerService;
  transactionService = services.transactionService;
  addressService = services.addressService;
  walletService = services.walletService;
}, 0);
